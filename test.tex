%!Tex Program = xelatex
%\documentclass[a4paper]{article}
\documentclass[a4paper]{ctexart}
\usepackage{xltxtra}
%\setmainfont[Mapping=tex-text]{AR PL UMing CN:style=Light}
%\setmainfont[Mapping=tex-text]{AR PL UKai CN:style=Book}
%\setmainfont[Mapping=tex-text]{WenQuanYi Zen Hei:style=Regular}
%\setmainfont[Mapping=tex-text]{WenQuanYi Zen Hei Sharp:style=Regular}
%\setmainfont[Mapping=tex-text]{AR PL KaitiM GB:style=Regular} 
%\setmainfont[Mapping=tex-text]{AR PL SungtiL GB:style=Regular} 
%\setmainfont[Mapping=tex-text]{WenQuanYi Zen Hei Mono:style=Regular} 

\usepackage{listings}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{mathrsfs}
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\usepackage{tikz}
\usetikzlibrary{trees}

\renewcommand{\thefigure}{\arabic{section}.\arabic{figure}}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\newcommand{\hl}[1]
{\noindent {\bf {#1}}}

% 创建定理环境  
\newtheorem{theorem}{定理}  

\theoremstyle{definition}  
\newtheorem{definition}{定义}[section]

\theoremstyle{definition}  
\newtheorem{example}{例}[section]  


\title{数据结构和算法}
\author{王何宇}
\date{}
\begin{document}
\maketitle
\pagestyle{empty}

\noindent 1. 假设数组 \verb|A| 的总长度为 $n$, 数组内全部元素从小到大排列, 
且数组内元素不重复. 请用\textbf{分治策略}写出一个算法, 
用来判断数组内是否存在某个元素 $x$. 如果存在, 返回该元素的下标; 如果不存在, 返回 $-1$. 
(提示: 数组下标从 \verb|0| 开始. 可以继续下面的伪代码.)
\begin{enumerate}
    \item[i]. 请写出该算法的伪代码. 
    \begin{verbatim}
        bisection (A, 0, n) :
            \\ 继续
    \end{verbatim}
    \item[ii]. 请问该算法的时间复杂度 $T(n)$ 是多少? 用 $O(\cdot)$ 或 $\Theta(\cdot)$ 表示. 这是主定理的哪一种情况? 
    (写出对应的条件和结论, 不要写第几种情况, 不必证明.)
    \item[iii]. 用数学归纳法证明 ii 的结论. (提示: 可以认为 $T(n) = O(n)$ 等价于存在 $c > 0$ 和 $n_0 > 0$, 
    使得 $T(n) \leq c \cdot n$ 对所有 $n \geq n_0$ 成立.) 
\end{enumerate}

\noindent 2. 用户依次输入 $3$, $7$, $2$, $1$, $4$, $9$, 形成一棵二叉搜索树. 
\begin{enumerate}
    \item[i].  请画出该二叉搜索树.
    \item[ii].  现在删除节点 $3$, 要求\textbf{在左子树中选取继承者(下同)}. 请写出具体步骤, 
    并画出删除节点 $3$ 后的二叉搜索树. 
    \item[iii]. 现在将该二叉搜索树看作是一颗 AVL 树, 左右子树最大高度差为 $1$. 
    插入节点 $11$, 请写出具体步骤, 并画出插入节点 $11$ 后的 AVL 树.
    \item[iv]. 再该 AVL 树中删除节点 $11$, 再插入 $6$, 请写出具体步骤, 
    并画出插入节点 $6$ 后的 AVL 树. 
\end{enumerate}

\noindent 3. 堆排序算法如下：
\begin{itemize}
    \item 构建\textbf{最大堆}：从最后一个非叶子节点开始，对所有非叶子节点进行下沉操作，确保每个子堆都是一个最大堆。
    \item 将堆顶元素（最大值）与数组末尾元素交换，然后将堆的大小减一。对新的堆顶元素进行下沉操作，
    以保持堆的性质。重复上述过程，直到堆的大小为 1。
\end{itemize}
\begin{enumerate}
    \item[i]. 已知数组初始状态是 $[3, 1, 2, 5, 7]$, 请写出建堆过程该数组的每一次变化. 
    (两数的交换看作一步)
    \item[ii]. 该排序算法是否原地, 请简要说明理由. 能否确保稳定? 如果能, 请给出具体策略; 
    如果不能, 请给一个反例.  
    \item[iii]. 如果数组长度是 $n$, 请问从初始数组到建堆完成的最坏时间复杂度 $T(n)$ 
    是多少? 
    \item[iv]. 请证明 iii 的结论.
\end{enumerate}

\noindent 4. 对数组 $[3, 5, 2, 1, 7]$ 进行快速排序. 
\begin{enumerate}
    \item[i]. 如果选择第一个元素作为 pivot, 请写出第一次划分的结果.
    \item[ii]. 请用文字描述快速排序法为保证效率, 如何处理:
    \begin{itemize}
        \item pivot 的选择策略；
        \item 递归的终止条件；
        \item 递归终止时的处理.
    \end{itemize}
\end{enumerate}

\noindent 5. 硬币找零问题的问题描述: 给定不同面额的硬币和一个总金额, 
计算组成总金额所需的最少硬币数量。比如硬币为 $[1, 2, 5]$, 总金额为 $11$, 
则最少硬币数量为 $3 (11 = 5 + 5 + 1)$. 请写出动态规划解法的伪代码:
\begin{itemize}
    \item 输入: 硬币面额数组 \verb|coins|, 硬币总金额 \verb|amount|;
    \item 输出: 组成总金额所需的最少硬币数量. 
    \item 提示 1 : 用 dp[i] 表示组成金额 i 所需的最少硬币数量.
    \item 提示 2 : 初始化 dp 数组, dp[0] = 0, dp[i] = amount + 1;
\end{itemize}

\noindent 6. 整数数组 \verb|A| 的长度为 $6$, 其中的元素初始都是 $-1$. 
完成如下合并操作: \verb|union(0, 1)|, \verb|union(0, 2)|, \verb|union(0, 3)|,
\verb|union(4, 5)|, \verb|union(3, 4)|.
\begin{enumerate}
    \item[i]. 请以 union-by-size 策略合并, 不采用路径压缩, 给出全部合并完成之后的数组, 
    并画出最终的并查集 (树形式).
    \item[ii]. 请以 union-by-height 策略合并,  不采用路径压缩, 给出全部合并完成之后的数组, 
    并画出最终的并查集 (树形式).
    \item[iii]. 请以 union-by-rank 策略合并, 采用路径压缩, 给出全部合并完成之后的数组, 
    并画出最终的并查集 (树形式). 
\end{enumerate}

\noindent 7. 以下有一个用邻接矩阵表示的有向图:
$$
\begin{array}{ccccccc}
    0 & 2 & \infty & 1 & \infty & \infty & \infty \\
    \infty & 0 & \infty & 3 & 10 & \infty & \infty \\
    4 & \infty & 0 & \infty & \infty & 5 & \infty \\
    \infty & \infty & 2 & 0 & 2 & 8 & 4 \\
    \infty & \infty & \infty & \infty & 0 & \infty & 6 \\
    \infty & \infty & \infty & \infty & \infty & 0 & \infty \\
    \infty & \infty & \infty & \infty & \infty & 1 & 0 \\
\end{array}
$$
\begin{enumerate}
    \item[i]. 画出该图. (提示: 图的顶点为 $\{0, 1, 2, 3, 4, 5, 6\}$.)
    \item[ii]. 请写出该图的邻接表表示. 
    (提示: 可以用 $(i, w(i))$ 表示第 $i$ 个节点和对应权重.)  
    \item[iii]. 令 $s = 3$, 请写出 Dijkstra 算法给出的从 $s$ 到其他节点的最短路径. 
    写出数组 $d$ 和 $p$ 的每一次变化. 这里 $d$ 表示从 $s$ 到其他节点的最短距离, 
    $p$ 表示最短路径的前驱节点. 
    (提示: $d$ 的初值为 $\{\infty, \infty, \infty, 0, \infty, \infty, \infty, \}$, 
    $p$ 的初值为 $\{-1, -1, -1, -1, -1, -1, -1\}$.)
\end{enumerate}

\noindent 8. 证明：设 $(u, v)$ 是图 $G$ 中权重最小的边, 
则 $(u, v)$ 属于 $G$ 的某棵最小生成树.

% \noindent 8. 如果一个图有 $n$ 个顶点和 $n - 1$ 条边, 那么它是连通的当且仅当它是树. 

% \noindent 7. 请写出一个算法, 用来判断一个有向图是否是有向无环图 (DAG).
% \begin{enumerate}
%     \item[i]. 用邻接表 \verb|graph| 表示有向图, 例如:
%     \begin{verbatim}
%         graph = {
%             0: [1, 2],
%             1: [2],
%             2: [3],
%             3: [4],
%             4: [1]
%         }
%     \end{verbatim} 
%     则可以对 \verb|graph[0]| 做 \verb|for each| 操作. 画出这个例子给出的图.
%     \item[ii]. 请写出该算法的伪代码. (提示: 可以根据需要使用堆栈.)
% \end{enumerate}


% \begin{tikzpicture}[
%     level distance=1.5cm,
%     level 1/.style={sibling distance=6cm},
%     level 2/.style={sibling distance=3cm},
%     edge from parent/.style={draw, -latex},
%     every node/.style={align=center}
%   ]
  
%   % Define the nodes with unique integer values
%   \node {10}
%     child {node {3}
%       child {node {1}}
%       child {node {6}}
%     }
%     child {node {15}
%       child {node {13}}
%       child {node {18}}
%     };
  
%   \end{tikzpicture}

\end{document}
